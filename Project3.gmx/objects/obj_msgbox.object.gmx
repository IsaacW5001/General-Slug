<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>msgs = ds_queue_create();   //A queue of strings we want to display

cur = 0; //Index of the current character we want to draw up to
wait = true;    //Boolean to check if we are waiting for input to advance the message

word_len = 0;   //Length of the current word. Set this variable at each space character

max_rows = 10;  //Maximum number of rows we can have in a message box. Let's assume its 10

line = 0;   //The current line we are printing. THIS IS DIFFERENT THAN THE row VALUE FOR DRAWING
//Initialize this array as a good practice
for(i = 0; i &lt; max_rows; i++)
{
    line_len[i] = 0;   //Length of a line
    line_chars[i] = 0;  //Count of characyers in a line. THIS IS DIFFERENT THAN THE col VALUE FOR DRAWING
}

line_chars[0] = cur;

line_kerning = 0;   //Account for pixels taken for kerning

//row = 0;    //The line we are writing characters to

global.formatting[0] = -1; //Array for formatting positions 

test = mdb_get(1, 2); //"This is a [r]test [s]message that should be [g]displayed. #Give me that [r]BIG [s]YIFF daddy.";
test = parse_text(test);

ds_queue_enqueue(msgs, test);

//Binary choices
//Encode these in the database

get = true;

wave = 0;

portrait = mdb_get(1, 1);
wait = 0;

//We will encode the portraits, text colors, and other shit in the text with control codes
//Sprite font defined as a macro because its easier
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//:thinking:
wait++;

//GOOD GRAFFIX
draw_set_font(fFont);
draw_set_color(c_black);
draw_rectangle(0, 0, view_wview[0], 128, false);
draw_set_color(c_white);
//draw_text(16,15,"GAY SHIT");

//Variables we are going to need
row = 0;
col = 0;    //The column we are writing the current character to
adjust = 0; //Font kerning aka seperation

c_text = c_white
shake = false;

offset = 0;

//if(!ds_queue_empty(msgs))
//    m = "";
//else
//m = ds_queue_dequeue(msgs); //Get the message at the head of the queue to display
if(get)
{
    m = ds_queue_dequeue(msgs);
    get = false;
}

//Draw each character individually
//for(i = 0; i &lt; string_length(m); i++)
for(i = 1; i &lt; cur; i++)
{
    //Get the length of the current word
    if(word_len == 0)
    {
        //Start at the current character shown
        word_len = cur;
        //Seek ahead for the next space character
        while(string_char_at(m, word_len) != " " &amp;&amp; word_len &lt; string_length(m))
            word_len++;
        
        //Subtract the index of the current character to derive the word length
        word_len -= cur;
    }

    //Font kerning, since we can't use a built in sprite font seperation
    //Adjust for your own font to look good
    /*if (i &gt; 0)
    {
        if (string_ord_at(m, i - 1) &gt;= 65 &amp;&amp; string_ord_at(m, i - 1) &lt;= 90)
            adjust -= 1;
        
        if (string_char_at(m, i - 1) == "I")
            adjust += 4;
        else if (string_char_at(m, i - 1) == "." || string_char_at(m, i - 1) == "!" || string_char_at(m, i - 1) == "i" || string_char_at(m, i - 1) == "l")
            adjust += 3;
        else if (string_char_at(m, i - 1) == "'" || string_char_at(m, i - 1) == "," || string_char_at(m, i - 1) == ";" || string_char_at(m, i - 1) == "j")
            adjust += 2;
        else if (string_char_at(m, i - 1) == "r" || string_char_at(m, i - 1) == "t" || string_char_at(m, i - 1) == "f" || string_char_at(m, i - 1) == "E" || string_char_at(m, i - 1) == "F" || string_char_at(m, i - 1) == "L" || string_char_at(m, i - 1) == "Z")
            adjust += 1;
        else if (string_char_at(m, i - 1) == "a" || string_char_at(m, i - 1) == "v" || string_char_at(m, i - 1) == "A" || string_char_at(m, i - 1) == "V")
            adjust -= 1;
        else if (string_char_at(m, i - 1) == "M" || string_char_at(m, i - 1) == "W" || string_char_at(m, i - 1) == "`")
            adjust -= 2;
        else if (string_char_at(m, i - 1) == "w" || string_char_at(m, i - 1) == "m")
            adjust -= 3;
        /*else
        adjust = 0;
    }*/
    
    //line_len[line] = (line_chars[line] * 6) - adjust;
            
    //Automatically wrap to new line if it would be longer than the text box width
    if((col*6) + 16 + ((word_len + 1) * 6) &gt; view_wview[0]-16)
    {
        row++;
        adjust = 0;
        col = 0;   //Consume line break
        //word_len = 0;
    }
    
    
    //Does the current character trigger something to happen?
    if(string_ord_at(m, i) == ord("#")) //Linebreak
    {
            row++;
            col = -1;   //Consume line break
            adjust = 0; //Since kerning is based on the previous character, ignore it
            //line_len = 0;
            word_len = 0;
    }
    
    if(string_ord_at(m, cur) == ord(" ")) //New word
            word_len = 0;
    

    //Draw the character, with seperation relative to the previous character
    //Use draw_text_color so we can use color control codes in the text
    //TEST: color formatting
    if(i &lt; array_length_1d(global.formatting))
    {
        if(global.formatting[i] != 0 &amp;&amp; string_char_at(m,i) != " ")
            if(global.formatting[i] == c_shake)
                shake = true;
            else
                c_text = global.formatting[i];
    }
    
    if(string_char_at(m,i) == " ")
    {
        shake = false;
        if(c_text != c_white)
            c_text = c_white;
        
    }
    
    if(shake)
    {
        offset = 3 * sin(i+wave);
        wave += 0.025;   
    }
    else
        offset = 0;
    
    draw_text_color(16 + (6 * col) - adjust + 1, 16 + (row*16) + offset, string_char_at(m, i), c_text, c_text, c_text, c_text, 1);

    col++;

}
    
//Play text sound
if(cur &lt; string_length(m) + 1 &amp;&amp; (wait mod 2 == 0))
{
    cur++;
    audio_play_sound(snd_text, 0, false);
}
draw_text(0, 80, string(line_len[line])+"#"+string(word_len)+"#"+string(adjust)+"#"+string(col+1)+", "+string(row+1));
draw_text(0, 0, string(fps));

//Draw character portait if there is one
if(portrait != noone)
    draw_sprite(portrait, 0, 0, 128);
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
